(1) Собеседование FRONTEND JS, TS задачи

Типы данных:
1. числа (number)
2. строки (string)
3. логические значения (boolean)
4. null (отсутствие значение)
5. undefined (не определенное значение)
6. большие числа (BigInt)
7. объект (object)
8. символ (symbol)

Методы массивов:
1. map - Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.

Параметры
callback
Функция, вызываемая для каждого элемента массива arr. Каждый раз, когда callback выполняется, возвращаемое значение добавляется в new_array.

Функция callback, создающая элемент в новом массиве, принимает три аргумента:

currentValue
Текущий обрабатываемый элемент массива.

indexНеобязательный
Индекс текущего обрабатываемого элемента в массиве.

arrayНеобязательный
Массив, по которому осуществляется проход.

thisArgНеобязательный
Необязательный параметр. Значение, используемое в качестве this при вызове функции callback

let result = arr.map(function(item, index, array) {
  // возвращается новое значение вместо элемента
});

2. filter - возвращает массив из всех элементов, удовлетворяющих условию

Параметры:
те же параметры, что у map

let results = arr.filter(function(item, index, array) {
  // если `true` -- элемент добавляется к results и перебор продолжается
  // возвращается пустой массив в случае, если ничего не найдено
});

let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];

// возвращает массив, состоящий из двух первых пользователей
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2

3. some - проверяет, удовлетворяет ли какой-либо элемент массива условию, заданному в передаваемой функции.

Параметры:
те же параметры, что у map

const array = [1, 2, 3, 4, 5];

// Checks whether an element is even
const even = (element) => element % 2 === 0;

console.log(array.some(even));
// Expected output: true

4. every - проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции.

Примечание: метод возвращает true при любом условии для пустого массива.

Параметры:
те же параметры, что у map

function isBigEnough(element, index, array) {
  return element >= 10;
}
[12, 5, 8, 130, 44].every(isBigEnough); // false
[12, 54, 18, 130, 44].every(isBigEnough); // true

5. includes - определяет, содержит ли массив определённый элемент, возвращая в зависимости от этого true или false.

Параметры:
searchElement
Искомый элемент.

fromIndex Необязательный
Позиция в массиве, с которой начинать поиск элемента searchElement. При отрицательных значениях поиск производится начиная с индекса array.length + fromIndex по возрастанию. Значение по умолчанию равно 0.

const array1 = [1, 2, 3];

console.log(array1.includes(2));
// Expected output: true

const pets = ['cat', 'dog', 'bat'];

console.log(pets.includes('cat'));
// Expected output: true

console.log(pets.includes('at'));
// Expected output: false

6. unshift - добавляет один или более элементов в начало массива и возвращает новую длину массива.

var arr = [1, 2];

arr.unshift(0); // результат вызова равен 3, новой длине массива
// arr равен [0, 1, 2]

arr.unshift(-2, -1); // = 5
// arr равен [-2, -1, 0, 1, 2]

7. slice - возвращает новый массив, содержащий копию части исходного массива.

Параметры:
begin Необязательный
Индекс (счёт начинается с нуля), по которому начинать извлечение.

end Необязательный
Индекс (счёт начинается с нуля), по которому заканчивать извлечение. Метод slice() извлекает элементы с индексом меньше end.

Пример:
var fruits = ["Банан", "Апельсин", "Лимон", "Яблоко", "Манго"];
var citrus = fruits.slice(1, 3);

// citrus содержит ['Апельсин', 'Лимон']

8. splice -  изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые.

Параметры:
start
Индекс, по которому начинает изменять массив. Если больше длины массива, реальный индекс будет установлен на длину массива. Если отрицателен, указывает индекс элемента с конца.

deleteCount Необязательный
Целое число, показывающее количество старых удаляемых из массива элементов. Если deleteCount равен 0, элементы не удаляются. В этом случае вы должны указать как минимум один новый элемент. Если deleteCount больше количества элементов, оставшихся в массиве, начиная с индекса start, то будут удалены все элементы до конца массива.

itemN Необязательный
Необязательные параметры. Добавляемые к массиву элементы. Если вы не укажете никакого элемента, splice() просто удалит элементы из массива.

var myFish = ["angel", "clown", "drum", "mandarin", "sturgeon"];
var removed = myFish.splice(3, 1);

// removed равен ["mandarin"]
// myFish равен ["angel", "clown", "drum", "sturgeon"]


Методы объектов: 

1) Метод Object.create() создаёт новый объект с указанным прототипом и свойствами.

Object.create(proto[, propertiesObject])

Параметры:
proto
Объект, который станет прототипом вновь созданного объекта.

propertiesObject
Необязательный параметр. Если указан и не равен undefined, должен быть объектом, чьи собственные перечисляемые свойства (то есть такие, которые определены на самом объекте, а не унаследованы по цепочке прототипов) указывают дескрипторы свойств, добавляемых в новый объект. Имена добавляемых свойств совпадают с именами свойств в этом объекте.

o = Object.create(Object.prototype, {
  // foo является рядовым 'свойством-значением'
  foo: { writable: true, configurable: true, value: "привет" },
  // bar является свойством с геттером и сеттером (свойством доступа)
  bar: {
    configurable: false,
    get: function () {
      return 10;
    },
    set: function (value) {
      console.log("Установка `o.bar` в", value);
    },
    /* при использовании методов доступа ES5 наш код мог бы выглядеть так:
    get function() { return 10; },
    set function(value) { console.log('Установка `o.bar` в', value); } */
  },
});

2) Метод Object.assign() используется для копирования значений всех собственных перечисляемых свойств из одного или более исходных объектов в целевой объект. После копирования он возвращает целевой объект.

Object.assign(target, ...sources)

 Он использует внутренний метод [[Get]] на исходных объектах и внутренний метод [[Set]] на целевом объекте, так что он также вызывает геттеры и сеттеры. Именно поэтому он присваивает свойства вместо простого копирования или определения новых свойств. Это поведение может сделать метод непригодным для вливания новых свойств в прототип, если вливаемые исходные объекты содержат геттеры. Вместо него для копирования в прототипы определений свойств, включая признак их перечисляемости, следует использовать методы Object.getOwnPropertyDescriptor() и Object.defineProperty().

2. Symbol
Symbol.iterator
Каждый раз, когда объект должен быть проитерирован (как, например, в начале цикла for..of), метод @@iterator вызывается без аргументов, а возвращённый итератор используется непосредственно для получения значений.

Некоторые встроенные типы имеют стандартное итерационное поведение, в то время как другие типы (как Object) таким свойством не обладают.

Пользовательские итерируемые объекты:
var myIterable = {};
myIterable[Symbol.iterator] = function* () {
  yield 1;
  yield 2;
  yield 3;
};
[...myIterable]; // [1, 2, 3]

Symbol.toPrimitive
является символом (symbol), который описывает свойство объекта как функцию, которая вызывается при преобразовании объекта в соответствующее примитивное значение.

const object1 = {
  [Symbol.toPrimitive](hint) {
    if (hint === 'number') {
      return 42;
    }
    return null;
  },
};

console.log(+object1);
// Expected output: 42